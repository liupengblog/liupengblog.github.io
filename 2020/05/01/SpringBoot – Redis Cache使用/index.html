<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="缓存,Redis,Cache,SpringBoot," />










<meta name="description" content="简介Spring Cache 提供了 @Cacheable 、@CachePut 、@CacheEvict 、@Caching 等注解，这些注解主要用在方法上。通过注解 Cache 可以实现类似事务一样、缓存逻辑透明的应用到我们的业务代码上，且只需要更少的代码。核心思想：当我们调用一个方法时会把该方法的参数和返回结果最为一个键值对存放在缓存中，等下次利用同样的参数来调用该方法时将不会再执行，而是直">
<meta property="og:type" content="article">
<meta property="og:title" content="SpringBoot – Redis Cache使用">
<meta property="og:url" content="http://yoursite.com/2020/05/01/SpringBoot%20%E2%80%93%20Redis%20Cache%E4%BD%BF%E7%94%A8/index.html">
<meta property="og:site_name" content="Sptan的blogs">
<meta property="og:description" content="简介Spring Cache 提供了 @Cacheable 、@CachePut 、@CacheEvict 、@Caching 等注解，这些注解主要用在方法上。通过注解 Cache 可以实现类似事务一样、缓存逻辑透明的应用到我们的业务代码上，且只需要更少的代码。核心思想：当我们调用一个方法时会把该方法的参数和返回结果最为一个键值对存放在缓存中，等下次利用同样的参数来调用该方法时将不会再执行，而是直">
<meta property="og:image" content="https://sptan-pic.oss-cn-shanghai.aliyuncs.com/rediscache/QQ20200429-135544.png">
<meta property="og:image" content="https://sptan-pic.oss-cn-shanghai.aliyuncs.com/rediscache/QQ20200429-135344.png">
<meta property="og:image" content="https://sptan-pic.oss-cn-shanghai.aliyuncs.com/rediscache/QQ20200429-135456.png">
<meta property="og:image" content="https://sptan-pic.oss-cn-shanghai.aliyuncs.com/rediscache/QQ20200505-174047.png">
<meta property="og:image" content="https://sptan-pic.oss-cn-shanghai.aliyuncs.com/rediscache/QQ20200505-174135.png">
<meta property="og:image" content="https://sptan-pic.oss-cn-shanghai.aliyuncs.com/rediscache/QQ20200505-174213.png">
<meta property="og:image" content="https://sptan-pic.oss-cn-shanghai.aliyuncs.com/rediscache/QQ20200505-174242.png">
<meta property="og:image" content="https://sptan-pic.oss-cn-shanghai.aliyuncs.com/rediscache/QQ20200505-180913.png">
<meta property="og:image" content="https://sptan-pic.oss-cn-shanghai.aliyuncs.com/rediscache/QQ20200505-181005.png">
<meta property="og:image" content="https://sptan-pic.oss-cn-shanghai.aliyuncs.com/rediscache/QQ20200505-183328.png">
<meta property="og:image" content="https://sptan-pic.oss-cn-shanghai.aliyuncs.com/rediscache/QQ20200505-184844.png">
<meta property="og:image" content="https://sptan-pic.oss-cn-shanghai.aliyuncs.com/rediscache/QQ20200505-185509.png">
<meta property="og:image" content="https://sptan-pic.oss-cn-shanghai.aliyuncs.com/rediscache/QQ20200505-185527.png">
<meta property="og:image" content="https://sptan-pic.oss-cn-shanghai.aliyuncs.com/rediscache/QQ20200505-220118.png">
<meta property="og:image" content="https://sptan-pic.oss-cn-shanghai.aliyuncs.com/rediscache/QQ20200505-220148.png">
<meta property="og:image" content="https://sptan-pic.oss-cn-shanghai.aliyuncs.com/rediscache/QQ20200506-122145.png">
<meta property="og:image" content="https://sptan-pic.oss-cn-shanghai.aliyuncs.com/rediscache/QQ20200506-135453.png">
<meta property="og:image" content="https://sptan-pic.oss-cn-shanghai.aliyuncs.com/rediscache/QQ20200506-135231.png">
<meta property="og:image" content="https://sptan-pic.oss-cn-shanghai.aliyuncs.com/rediscache/QQ20200506-141912.png">
<meta property="og:image" content="https://sptan-pic.oss-cn-shanghai.aliyuncs.com/rediscache/QQ20200506-142244.png">
<meta property="og:image" content="https://sptan-pic.oss-cn-shanghai.aliyuncs.com/rediscache/QQ20200506-142606.png">
<meta property="og:image" content="https://sptan-pic.oss-cn-shanghai.aliyuncs.com/rediscache/QQ20200506-150425.png">
<meta property="og:image" content="https://sptan-pic.oss-cn-shanghai.aliyuncs.com/rediscache/QQ20200506-151641.png">
<meta property="og:image" content="https://sptan-pic.oss-cn-shanghai.aliyuncs.com/rediscache/QQ20200506-152115.png">
<meta property="og:image" content="https://sptan-pic.oss-cn-shanghai.aliyuncs.com/rediscache/QQ20200506-152633.png">
<meta property="og:image" content="https://sptan-pic.oss-cn-shanghai.aliyuncs.com/rediscache/QQ20200506-153710.png">
<meta property="og:image" content="https://sptan-pic.oss-cn-shanghai.aliyuncs.com/rediscache/QQ20200506-153918.png">
<meta property="article:published_time" content="2020-04-30T16:00:00.000Z">
<meta property="article:modified_time" content="2020-05-08T04:14:08.114Z">
<meta property="article:author" content="Sptan">
<meta property="article:tag" content="缓存">
<meta property="article:tag" content="Redis">
<meta property="article:tag" content="Cache">
<meta property="article:tag" content="SpringBoot">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://sptan-pic.oss-cn-shanghai.aliyuncs.com/rediscache/QQ20200429-135544.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/05/01/SpringBoot – Redis Cache使用/"/>





  <title>SpringBoot – Redis Cache使用 | Sptan的blogs</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Sptan的blogs</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">懒惰的码农</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/01/SpringBoot%20%E2%80%93%20Redis%20Cache%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sptan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://sptan-public.oss-cn-beijing.aliyuncs.com/sptanlp.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sptan的blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">SpringBoot – Redis Cache使用</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-01T00:00:00+08:00">
                2020-05-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SpringBoot/" itemprop="url" rel="index">
                    <span itemprop="name">SpringBoot</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Spring Cache 提供了 @Cacheable 、@CachePut 、@CacheEvict 、@Caching 等注解，这些注解主要用在方法上。通过注解 Cache 可以实现类似事务一样、缓存逻辑透明的应用到我们的业务代码上，且只需要更少的代码。<br>核心思想：当我们调用一个方法时会把该方法的参数和返回结果最为一个键值对存放在缓存中，等下次利用同样的参数来调用该方法时将不会再执行，而是直接从缓存中获取结果进行返回。</p>
<a id="more"></a>

<h1 id="SpringBoot-中启用-Redis-缓存"><a href="#SpringBoot-中启用-Redis-缓存" class="headerlink" title="SpringBoot 中启用 Redis 缓存"></a>SpringBoot 中启用 Redis 缓存</h1><p>Spring 的 Context 环境中已经提供了 Cache 的实现，Cache 实现有几种方式，我们这里只讨论 redis。通过在 maven 中引入 redis 相关的依赖，并且在 Springboot 的启动类或者配置类中增加@EnableCaching 注解即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>我们在 SpringBoot 启动类中增加@EnableCaching 注解：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableCaching</span><br><span class="line">public class RediscacheApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(RediscacheApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然也可以把注解放在配置类上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableCaching</span><br><span class="line">public class CachingConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public CacheManager cacheManager() &#123;</span><br><span class="line">        return new ConcurrentMapCacheManager(&quot;addresses&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="使用注解式缓存"><a href="#使用注解式缓存" class="headerlink" title="使用注解式缓存"></a>使用注解式缓存</h1><p>下面的代码均以 Banner 的增删改查为例来说明 Redis Cache 的使用。<br>要使用 Redis，配置文件中要进行 Redis 的配置：<br>下面是项目的 application-dev.yaml 文件中 Redis 相关配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#配置数据源</span><br><span class="line">spring:</span><br><span class="line">  redis:</span><br><span class="line">    #数据库索引</span><br><span class="line">    database: 3</span><br><span class="line">    host: 127.0.0.1</span><br><span class="line">    port: 6379</span><br><span class="line">    password:</span><br><span class="line">    #连接超时时间</span><br><span class="line">    timeout: 50000</span><br></pre></td></tr></table></figure>

<p>下面举例过程中，我们一方面观察对应 RedisCache 的配置代码，一方面通过 Redis 客户端观察我们的代码和操作对缓存的影响效果。</p>
<ul>
<li>为了方便测试，我们的 Redis 缓存时间设置为 1 分钟，配置方法本文后面配置部分会讲到；</li>
<li>例子代码中接口以 Swagger 进行封装，通过在 Swagger 界面调用接口完成我们的操作；</li>
<li>初始化状态下，Redis 中没有数据。<br><img src="https://sptan-pic.oss-cn-shanghai.aliyuncs.com/rediscache/QQ20200429-135544.png" alt=""></li>
</ul>
<h1 id="主要注解的解释"><a href="#主要注解的解释" class="headerlink" title="主要注解的解释"></a>主要注解的解释</h1><h2 id="CacheConfig"><a href="#CacheConfig" class="headerlink" title="@CacheConfig"></a>@CacheConfig</h2><p>主要用于配置该类中会用到的一些共用的缓存配置。<br>在这里 @CacheConfig(cacheNames = “users”)：配置了该数据访问对象中返回的内容将存储于名为 users 的缓存对象中，我们也可以不使用该注解，直接通过 @Cacheable 自己配置缓存集的名字来定义。</p>
<h2 id="Cacheable"><a href="#Cacheable" class="headerlink" title="@Cacheable"></a>@Cacheable</h2><p>主要针对方法配置，能够根据方法的请求参数对其结果进行缓存。同时在查询时，会先从缓存中获取，若不存在才再发起对数据库的访问。该注解主要有下面几个参数：</p>
<ul>
<li><p>value、cacheNames</p>
<p>两个等同的参数（cacheNames 为 Spring 4 新增，作为 value 的别名），用于指定缓存存储的集合名。由于 Spring 4 中新增了 @CacheConfig，因此在 Spring 3 中原本必须有的 value 属性，也成为非必需项了。</p>
</li>
<li><p>key</p>
<p>缓存对象存储在 Map 集合中的 key 值，非必需，缺省按照函数的所有参数组合作为 key 值，若自己配置需使用 SpEL 表 达式，比如：@Cacheable(key = “#p0”)：使用函数第一个参数作为缓存的 key 值，更多关于 SpEL 表达式的详细内容可参考官方文档。</p>
</li>
<li><p>condition</p>
<p>缓存对象的条件，非必需，也需使用 SpEL 表达式，只有满足表达式条件的内容才会被缓存，比如：@Cacheable(key = “#p0”, condition = “#p0.length() &lt; 3”)，表示只有当第一个参数的长度小于 3 的时候才会被缓存，若做此配置上面的 AAA 用户就不会被缓存，读者可自行实验尝试。</p>
</li>
<li><p>unless</p>
<p>另外一个缓存条件参数，非必需，需使用 SpEL 表达式。它不同于 condition 参数的地方在于它的判断时机，该条件是在函数被调用之后才做判断的，所以它可以通过对 result 进行判断。</p>
</li>
<li><p>keyGenerator</p>
<p>用于指定 key 生成器，非必需。若需要指定一个自定义的 key 生成器，我们需要去实现 org.springframework.cache.interceptor.KeyGenerator 接口，并使用该参数来指定。需要注意的是，该参数与 key 是互斥的。</p>
</li>
<li><p>cacheManager</p>
<p>用于指定使用哪个缓存管理器，非必需。只有当有多个时才需要使用。</p>
</li>
<li><p>cacheResolver</p>
<pre><code>用于指定使用那个缓存解析器，非必需。需通过</code></pre><p>org.springframework.cache.interceptor.CacheResolver 接口来实现自己的缓存解析器，并用该参数指定。</p>
</li>
</ul>
<h2 id="CachePut"><a href="#CachePut" class="headerlink" title="@CachePut"></a>@CachePut</h2><p>配置于方法上，能够根据参数定义条件来进行缓存，它与 @Cacheable 不同的是，它不会去检查缓存中是否存在之前执行过的结果，而是每次都会执行该方法，并将执行结果以键值对的形式存入缓存中，所以主要用于数据新增和修改操作上。它的参数与 @Cacheable 类似，具体功能可参考上面对 @Cacheable 参数的解析。</p>
<h2 id="CacheEvict"><a href="#CacheEvict" class="headerlink" title="@CacheEvict"></a>@CacheEvict</h2><p>配置于函数上，通常用在删除方法上，用来从缓存中移除相应数据。除了同 @Cacheable 一样的参数之外，它还有下面两个参数：</p>
<ul>
<li><p>allEntries</p>
<p>非必需，默认为 false。当为 true 时，会移除所有数据。</p>
</li>
<li><p>beforeInvocation</p>
<p>非必需，默认为 false，会在调用方法之后移除数据；当为 true 时，会在调用方法之前移除数据。</p>
</li>
</ul>
<h2 id="Cacheable-使用举例"><a href="#Cacheable-使用举例" class="headerlink" title="@Cacheable 使用举例"></a>@Cacheable 使用举例</h2><p>@Cacheable 可以标记在一个方法上，也可以标记在一个类上。当标记在一个方法上时表示该方法是支持缓存的，当标记在一个类上时则表示该类所有的方法都是支持缓存的。对于一个支持缓存的方法，Spring 会在其被调用后将其返回值缓存起来，以保证下次利用同样的参数来执行该方法时可以直接从缓存中获取结果，而不需要再次执行该方法。Spring 在缓存方法的返回值时是以键值对进行缓存的，值就是方法的返回结果，至于键的话，Spring 又支持两种策略，默认策略和自定义策略，这个稍后会进行说明。<br><strong>需要注意的是当一个支持缓存的方法在对象内部被调用时是不会触发缓存功能的。</strong><br>@Cacheable 可以指定三个属性，value、key 和 condition。</p>
<h3 id="查询单个对象"><a href="#查询单个对象" class="headerlink" title="查询单个对象"></a>查询单个对象</h3><p>@Cacheable 的 value 属性是必须指定的，其表示当前方法的返回值是会被缓存在哪个 Cache 上的，对应 Cache 的名称。其可以是一个 Cache 也可以是多个 Cache，当需要指定多个 Cache 时其是一个数组。查询单个对象时的一个例子如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Cacheable(value &#x3D; &quot;banner&quot;, key &#x3D; &quot;#p0&quot;)</span><br><span class="line">public BannerDTO findById(String id) &#123;</span><br><span class="line">    Banner banner &#x3D; bannerRepository.findById(id).orElseGet(Banner::new);</span><br><span class="line">    ValidationUtil.isNull(banner.getId(), &quot;Banner&quot;, &quot;id&quot;, id);</span><br><span class="line">    return bannerMapper.toDto(banner);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子中会把结果缓存在 banner 中，缓存的键值为参数 id 的值。<br>swagger 画面中调用上述单个对象的查询接口:<br><img src="https://sptan-pic.oss-cn-shanghai.aliyuncs.com/rediscache/QQ20200429-135344.png" alt=""></p>
<p>缓存结果如下:<br><img src="https://sptan-pic.oss-cn-shanghai.aliyuncs.com/rediscache/QQ20200429-135456.png" alt=""></p>
<h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Cacheable(value&#x3D;&quot;queryByPage&quot;)</span><br><span class="line">public Map&lt;String, Object&gt; queryByPage(BannerQueryCriteria criteria, Pageable pageable) &#123;</span><br><span class="line">    Page&lt;Banner&gt; page &#x3D;</span><br><span class="line">            bannerRepository.findAll((root, criteriaQuery, criteriaBuilder) -&gt; QueryHelp.getPredicate(root, criteria,</span><br><span class="line">                    criteriaBuilder), pageable);</span><br><span class="line">    return PageUtil.toPage(page.map(bannerMapper::toDto));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不指定任何参数，在 swagger 中执行查询操作:<br><img src="https://sptan-pic.oss-cn-shanghai.aliyuncs.com/rediscache/QQ20200505-174047.png" alt=""></p>
<p>缓存结果如下:</p>
<p><img src="https://sptan-pic.oss-cn-shanghai.aliyuncs.com/rediscache/QQ20200505-174135.png" alt=""></p>
<p>参数中增加查询条件:<br><img src="https://sptan-pic.oss-cn-shanghai.aliyuncs.com/rediscache/QQ20200505-174213.png" alt=""></p>
<p>缓存结果如下:<br><img src="https://sptan-pic.oss-cn-shanghai.aliyuncs.com/rediscache/QQ20200505-174242.png" alt=""></p>
<p>可以看出 Spring 已经根据方法的执行参数自动生成了缓存 key。</p>
<h3 id="为-Service-设置-CacheNames"><a href="#为-Service-设置-CacheNames" class="headerlink" title="为 Service 设置 CacheNames"></a>为 Service 设置 CacheNames</h3><p>为 Service 类增加 CacheNames 属性,这个属性指定后会作为类中默认的 cache 名称，如果方法中没有指定 cache 的名字，就把类中设置的 CacheNames 属性作为 Cache 的名字:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">&#x2F;&#x2F;为Service设置CacheNames</span><br><span class="line">@CacheConfig(cacheNames &#x3D; &quot;banner&quot;)</span><br><span class="line">@Transactional(rollbackFor &#x3D; Exception.class)</span><br><span class="line">public class BannerServiceImpl implements BannerService &#123;</span><br></pre></td></tr></table></figure>

<p>方法中的@Cacheable 去掉 value 属性:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Cacheable()</span><br><span class="line">public Map&lt;String, Object&gt; queryByPage(BannerQueryCriteria criteria, Pageable pageable) &#123;</span><br><span class="line">    Page&lt;Banner&gt; page &#x3D;</span><br><span class="line">            bannerRepository.findAll((root, criteriaQuery, criteriaBuilder) -&gt; QueryHelp.getPredicate(root, criteria,</span><br><span class="line">                    criteriaBuilder), pageable);</span><br><span class="line">    return PageUtil.toPage(page.map(bannerMapper::toDto));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再进行一次没有查询条件的分页查询:<br><img src="https://sptan-pic.oss-cn-shanghai.aliyuncs.com/rediscache/QQ20200505-180913.png" alt=""></p>
<p>结果如下:<br><img src="https://sptan-pic.oss-cn-shanghai.aliyuncs.com/rediscache/QQ20200505-181005.png" alt=""></p>
<p>这种情况下，缓存完成的键值如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">banner::SimpleKey [BannerQueryCriteria(bannerName&#x3D;null, showLocation&#x3D;null),Page request [number: 0, size 20, sort: updateTime: DESC]]</span><br></pre></td></tr></table></figure>

<p>我们再指定 key 看看效果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Cacheable(key &#x3D; &quot;&#39;key:p0:&#39; + #p0.hashCode() + &#39;p1:&#39; + #p1.hashCode()&quot;)</span><br><span class="line">public Map&lt;String, Object&gt; queryByPage(BannerQueryCriteria criteria, Pageable pageable) &#123;</span><br><span class="line">    Page&lt;Banner&gt; page &#x3D;</span><br><span class="line">            bannerRepository.findAll((root, criteriaQuery, criteriaBuilder) -&gt; QueryHelp.getPredicate(root, criteria,</span><br><span class="line">                    criteriaBuilder), pageable);</span><br><span class="line">    return PageUtil.toPage(page.map(bannerMapper::toDto));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Redis 缓存效果如下:<br><img src="https://sptan-pic.oss-cn-shanghai.aliyuncs.com/rediscache/QQ20200505-183328.png" alt=""></p>
<p>可以看到 key 比之前短了一些。</p>
<h2 id="CacheEvict-使用举例"><a href="#CacheEvict-使用举例" class="headerlink" title="@CacheEvict 使用举例"></a>@CacheEvict 使用举例</h2><p>@CacheEvict 用于删除缓存。<br>随着缓存的积累，缓存越来越多，会占用过多的空间，这个注解可以删除缓存。<br>我们现在把缓存的时间设置长一些，多积累一些缓存，然后通过@CacheEvict 注解一次全部删除。</p>
<p>下面这个代码片段把缓存时间长度设置为 1 小时:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GenericJackson2JsonRedisSerializer genericJackson2JsonRedisSerializer &#x3D;</span><br><span class="line">        new GenericJackson2JsonRedisSerializer();</span><br><span class="line">RedisCacheConfiguration defaultCacheConfig &#x3D; RedisCacheConfigurationdefaultCacheConfig()</span><br><span class="line">        .serializeValuesWith(</span><br><span class="line">        RedisSerializationContext.SerializationPair.fromSerializer(genericJackson2JsonRedisSerializer))</span><br><span class="line">        .entryTtl(Duration.ofMinutes(60));</span><br></pre></td></tr></table></figure>

<p>我们这里设置为创建一个 banner 时便清空缓存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@CacheEvict(allEntries &#x3D; true)</span><br><span class="line">@Transactional(rollbackFor &#x3D; Exception.class)</span><br><span class="line">public BannerDTO create(Banner resources) &#123;</span><br><span class="line">    resources.setId(IdUtil.simpleUUID());</span><br><span class="line">    return bannerMapper.toDto(bannerRepository.save(resources));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过多次查询缓存效果:</p>
<p><img src="https://sptan-pic.oss-cn-shanghai.aliyuncs.com/rediscache/QQ20200505-184844.png" alt=""></p>
<p>执行一次 create 接口，创建一个 banner 后缓存效果:</p>
<p><img src="https://sptan-pic.oss-cn-shanghai.aliyuncs.com/rediscache/QQ20200505-185509.png" alt=""></p>
<p><img src="https://sptan-pic.oss-cn-shanghai.aliyuncs.com/rediscache/QQ20200505-185527.png" alt=""><br>可以看到新增 banner 后缓存就全部清空了。</p>
<h2 id="CachePut-使用举例"><a href="#CachePut-使用举例" class="headerlink" title="@CachePut 使用举例"></a>@CachePut 使用举例</h2><p>对于使用@Cacheable 标注的方法，Spring 在每次执行前都会检查 Cache 中是否存在相同 key 的缓存元素，如果存在就不再执行该方法，而是直接从缓存中获取结果进行返回，否则才会执行并将返回结果存入指定的缓存中。@CachePut 也可以声明一个方法支持缓存功能。与@Cacheable 不同的是使用@CachePut 标注的方法在执行前不会去检查缓存中是否存在之前执行过的结果，而是每次都会执行该方法，并将执行结果以键值对的形式存入指定的缓存中。<br>@CachePut 也可以标注在类上和方法上。使用@CachePut 时我们可以指定的属性跟@Cacheable 是一样的。</p>
<p>还是上面例子中的 create 方法，我们这次改为创建一个 banner 对象后立即缓存到 redis 中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@CachePut(value &#x3D; &quot;banner&quot;, key &#x3D; &quot;#result.getId()&quot;)</span><br><span class="line">@Transactional(rollbackFor &#x3D; Exception.class)</span><br><span class="line">public BannerDTO create(Banner resources) &#123;</span><br><span class="line">    resources.setId(IdUtil.simpleUUID());</span><br><span class="line">    return bannerMapper.toDto(bannerRepository.save(resources));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行 create 方法:<br><img src="https://sptan-pic.oss-cn-shanghai.aliyuncs.com/rediscache/QQ20200505-220118.png" alt=""></p>
<p>查看缓存结果:<br><img src="https://sptan-pic.oss-cn-shanghai.aliyuncs.com/rediscache/QQ20200505-220148.png" alt=""></p>
<h2 id="Caching-使用举例"><a href="#Caching-使用举例" class="headerlink" title="@Caching 使用举例"></a>@Caching 使用举例</h2><p>@Caching 注解可以让我们在一个方法或者类上同时指定多个 Spring Cache 相关的注解。其拥有三个属性：cacheable、put 和 evict，分别用于指定@Cacheable、@CachePut 和@CacheEvict。<br>这个我基本不使用，我还没有想明白这个注解的使用场景和价值在什么地方。<br>仅仅截取几个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Caching(evict &#x3D; &#123;</span><br><span class="line">  @CacheEvict(&quot;addresses&quot;),</span><br><span class="line">  @CacheEvict(value&#x3D;&quot;directory&quot;, key&#x3D;&quot;#customer.name&quot;) &#125;)</span><br><span class="line">public String getAddress(Customer customer) &#123;...&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Caching(cacheable &#x3D; @Cacheable(&quot;users&quot;),</span><br><span class="line">         evict &#x3D; &#123;</span><br><span class="line">           @CacheEvict(&quot;cache2&quot;),</span><br><span class="line">           @CacheEvict(value &#x3D; &quot;cache3&quot;, allEntries &#x3D; true)</span><br><span class="line">        &#125;</span><br><span class="line">       )</span><br><span class="line">   public User find(Integer id) &#123;</span><br><span class="line">      returnnull;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>等我想明白这个注解的好处之后再补充相关的例子和说明。</p>
<h2 id="CacheConfig-使用举例"><a href="#CacheConfig-使用举例" class="headerlink" title="@CacheConfig 使用举例"></a>@CacheConfig 使用举例</h2><p>@CacheConfig 注解用于类而不用于方法，可以给某个类的所有方法设置相同的注解属性。</p>
<ul>
<li>cacheNames : 指定 Cache 名称</li>
<li>keyGenerator : 指定键值生成器</li>
<li>cacheManager : 指定 cacheManager，没有的话使用默认的 org.springframework.cache.CacheManager</li>
<li>cacheResolver : 指定 CacheResolver，没有的话使用默认的 org.springframework.cache.CacheResolver<br>我们上面的例子中，Cache 中都有 banner 开头，就是因为我们在 Service 类中指定了 cacheNames 属性。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">@CacheConfig(cacheNames &#x3D; &quot;banner&quot;)</span><br><span class="line">@Transactional(rollbackFor &#x3D; Exception.class)</span><br><span class="line">public class BannerServiceImpl implements BannerService &#123;</span><br><span class="line">    &#x2F;&#x2F;......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="条件式缓存"><a href="#条件式缓存" class="headerlink" title="条件式缓存"></a>条件式缓存</h1><h2 id="条件参数"><a href="#条件参数" class="headerlink" title="条件参数"></a>条件参数</h2><p>缓存对象的条件，非必需，也需使用 SpEL 表达式，只有满足表达式条件的内容才会被缓存，比如：@Cacheable(key = “#p0”, condition = “#p0.length() &lt; 3”)，表示只有当第一个参数的长度小于 3 的时候才会被缓存。<br>下面的例子中只把 name 属性为 Tom 的 customer 缓存起来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@CachePut(value&#x3D;&quot;addresses&quot;, condition&#x3D;&quot;#customer.name&#x3D;&#x3D;&#39;Tom&#39;&quot;)</span><br><span class="line">public String getAddress(Customer customer) &#123;...&#125;</span><br></pre></td></tr></table></figure>

<h2 id="排除性条件参数"><a href="#排除性条件参数" class="headerlink" title="排除性条件参数"></a>排除性条件参数</h2><p>排除性缓存条件参数，非必需，需使用 SpEL 表达式。它不同于 condition 参数的地方在于它的判断时机，该条件是在函数被调用之后才做判断的，所以它可以通过对 result 进行判断。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@CachePut(value&#x3D;&quot;addresses&quot;, unless&#x3D;&quot;#result.length()&lt;64&quot;)</span><br><span class="line">public String getAddress(Customer customer) &#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>这个表示缓存长度大于等于 64 的地址。</p>
<p>根据 spring 文档说明， condition 参数与 unless 参数的最大区别在判断时机而不是判断条件的是与非。为什么设计不得而知，研究明白后再更新本文档。</p>
<h1 id="常用缓存配置"><a href="#常用缓存配置" class="headerlink" title="常用缓存配置"></a>常用缓存配置</h1><h2 id="失效时间设定"><a href="#失效时间设定" class="headerlink" title="失效时间设定"></a>失效时间设定</h2><p>默认缓存过期时间为-1，即一直有效。实际中我们大多数场景都需要一个固定实效的期限。<br>我们前面的例子中设置的缓存存活时间为 1 分钟或者 1 小时。以下是缓存存活 1 小时的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@Configuration</span><br><span class="line">@ConditionalOnClass(RedisOperations.class)</span><br><span class="line">@EnableConfigurationProperties(RedisProperties.class)</span><br><span class="line">@EnableCaching</span><br><span class="line">public class RedisConfig extends CachingConfigurerSupport &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RedisProperties redisProperties;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    @Bean</span><br><span class="line">    public CacheManager cacheManager() &#123;</span><br><span class="line">        GenericJackson2JsonRedisSerializer genericJackson2JsonRedisSerializer &#x3D;</span><br><span class="line">                new GenericJackson2JsonRedisSerializer();</span><br><span class="line">        RedisCacheConfiguration defaultCacheConfig &#x3D; RedisCacheConfiguration.defaultCacheConfig()</span><br><span class="line">                .serializeValuesWith(</span><br><span class="line">                RedisSerializationContext.SerializationPair.fromSerializer(genericJackson2JsonRedisSerializer))</span><br><span class="line">                .entryTtl(Duration.ofMinutes(60)); &#x2F;&#x2F;缓存60分钟失效</span><br><span class="line"></span><br><span class="line">        CustomRedisCacheManager redisCacheManager &#x3D;</span><br><span class="line">                new CustomRedisCacheManager(RedisCacheWriter.nonLockingRedisCacheWriter(redisConnectionFactory()), defaultCacheConfig);</span><br><span class="line">        return redisCacheManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="更精确一点的配置"><a href="#更精确一点的配置" class="headerlink" title="更精确一点的配置"></a>更精确一点的配置</h2><h3 id="准备-Cache-配置："><a href="#准备-Cache-配置：" class="headerlink" title="准备 Cache 配置："></a>准备 Cache 配置：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">@EnableCaching &#x2F;&#x2F; 使用了CacheManager，别忘了开启它  否则无效</span><br><span class="line">@Configuration</span><br><span class="line">public class CacheConfig extends CachingConfigurerSupport &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public CacheManager cacheManager() &#123;</span><br><span class="line">        RedisCacheConfiguration defaultCacheConfig &#x3D; RedisCacheConfiguration.defaultCacheConfig()</span><br><span class="line">                .entryTtl(Duration.ofDays(1)) &#x2F;&#x2F; 默认没有特殊指定的</span><br><span class="line">                .computePrefixWith(cacheName -&gt; &quot;caching:&quot; + cacheName);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 针对不同cacheName，设置不同的过期时间</span><br><span class="line">        Map&lt;String, RedisCacheConfiguration&gt; initialCacheConfiguration &#x3D; new HashMap&lt;String, RedisCacheConfiguration&gt;() &#123;&#123;</span><br><span class="line">            put(&quot;demoCache&quot;, RedisCacheConfiguration.defaultCacheConfig().entryTtl(Duration.ofHours(1))); &#x2F;&#x2F;1小时</span><br><span class="line">            put(&quot;demoCar&quot;, RedisCacheConfiguration.defaultCacheConfig().entryTtl(Duration.ofMinutes(10))); &#x2F;&#x2F; 10分钟</span><br><span class="line">            &#x2F;&#x2F; ...</span><br><span class="line">        &#125;&#125;;</span><br><span class="line"></span><br><span class="line">        RedisCacheManager redisCacheManager &#x3D; RedisCacheManager.builder(redisConnectionFactory())</span><br><span class="line">                .cacheDefaults(defaultCacheConfig) &#x2F;&#x2F; 默认配置（强烈建议配置上）。  比如动态创建出来的都会走此默认配置</span><br><span class="line">                .withInitialCacheConfigurations(initialCacheConfiguration) &#x2F;&#x2F; 不同cache的个性化配置</span><br><span class="line">                .build();</span><br><span class="line">        return redisCacheManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public RedisConnectionFactory redisConnectionFactory() &#123;</span><br><span class="line">        RedisStandaloneConfiguration configuration &#x3D; new RedisStandaloneConfiguration();</span><br><span class="line">        configuration.setHostName(&quot;10.102.132.150&quot;);</span><br><span class="line">        configuration.setPort(6379);</span><br><span class="line">        configuration.setDatabase(0);</span><br><span class="line">        LettuceConnectionFactory factory &#x3D; new LettuceConnectionFactory(configuration);</span><br><span class="line">        return factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public RedisTemplate&lt;String, String&gt; stringRedisTemplate() &#123;</span><br><span class="line">        RedisTemplate&lt;String, String&gt; redisTemplate &#x3D; new StringRedisTemplate();</span><br><span class="line">        redisTemplate.setConnectionFactory(redisConnectionFactory());</span><br><span class="line">        return redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用实例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class CacheDemoServiceImpl implements CacheDemoService &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Caching(cacheable &#x3D; &#123;</span><br><span class="line">            @Cacheable(cacheNames &#x3D; &quot;demoCache&quot;, key &#x3D; &quot;#id + 0&quot;),</span><br><span class="line">            @Cacheable(cacheNames &#x3D; &quot;demoCar&quot;, key &#x3D; &quot;#id + 10&quot;),</span><br><span class="line">            @Cacheable(cacheNames &#x3D; &quot;demoFsx&quot;, key &#x3D; &quot;#id + 100&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    @Override</span><br><span class="line">    public Object getFromDB(Integer id) &#123;</span><br><span class="line">        System.out.println(&quot;模拟去db查询~~~&quot; + id);</span><br><span class="line">        return &quot;hello cache...&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行单元测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@ContextConfiguration(classes &#x3D; &#123;RootConfig.class, CacheConfig.class&#125;)</span><br><span class="line">public class TestSpringBean &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private CacheDemoService cacheDemoService;</span><br><span class="line">    @Autowired</span><br><span class="line">    private CacheManager cacheManager;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test1() &#123;</span><br><span class="line">        cacheDemoService.getFromDB(1);</span><br><span class="line">        cacheDemoService.getFromDB(1);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;----------验证缓存是否生效----------&quot;);</span><br><span class="line">        Cache cache &#x3D; cacheManager.getCache(&quot;demoCache&quot;);</span><br><span class="line">        System.out.println(cache);</span><br><span class="line">        System.out.println(cache.get(1, String.class));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果:<br><img src="https://sptan-pic.oss-cn-shanghai.aliyuncs.com/rediscache/QQ20200506-122145.png" alt=""><br>可以看到，demoFsx 使用默认的设置，缓存时间为 1 天，另外两个使用独自设置的缓存过期时间。</p>
<h2 id="单个方法级别的缓存失效时间配置"><a href="#单个方法级别的缓存失效时间配置" class="headerlink" title="单个方法级别的缓存失效时间配置"></a>单个方法级别的缓存失效时间配置</h2><p>最精确的是为每个缓存项目指定失效日期，如下所示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Cacheable(cacheNames &#x3D; &quot;demoCache#3600&quot;, key &#x3D; &quot;#id + 0&quot;),</span><br></pre></td></tr></table></figure>

<p>通过#分隔，后面部分表示此 Cache 的 TTL（单位：秒）</p>
<p>为了实现这个效果，其实并不难，只需要对 RedisCacheManager 稍稍的改造一下即可达到目的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class MyRedisCacheManager extends RedisCacheManager &#123;</span><br><span class="line"></span><br><span class="line">    public MyRedisCacheManager(RedisCacheWriter cacheWriter, RedisCacheConfiguration defaultCacheConfiguration) &#123;</span><br><span class="line">        super(cacheWriter, defaultCacheConfiguration);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected RedisCache createRedisCache(String name, RedisCacheConfiguration cacheConfig) &#123;</span><br><span class="line">        String[] array &#x3D; StringUtils.delimitedListToStringArray(name, &quot;#&quot;);</span><br><span class="line">        name &#x3D; array[0];</span><br><span class="line">        if (array.length &gt; 1) &#123; &#x2F;&#x2F; 解析TTL</span><br><span class="line">            long ttl &#x3D; Long.parseLong(array[1]);</span><br><span class="line">            cacheConfig &#x3D; cacheConfig.entryTtl(Duration.ofSeconds(ttl)); &#x2F;&#x2F; 注意单位我此处用的是秒，而非毫秒</span><br><span class="line">        &#125;</span><br><span class="line">        return super.createRedisCache(name, cacheConfig);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用我自定义的 MyRedisCacheManager 配置 CacheConfig 如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@EnableCaching &#x2F;&#x2F; 使用了CacheManager，别忘了开启它  否则无效</span><br><span class="line">@Configuration</span><br><span class="line">public class CacheConfig extends CachingConfigurerSupport &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public CacheManager cacheManager() &#123;</span><br><span class="line">        RedisCacheConfiguration defaultCacheConfig &#x3D; RedisCacheConfiguration.defaultCacheConfig()</span><br><span class="line">                .entryTtl(Duration.ofDays(1))</span><br><span class="line">                .computePrefixWith(cacheName -&gt; &quot;caching:&quot; + cacheName);</span><br><span class="line"></span><br><span class="line">        MyRedisCacheManager redisCacheManager &#x3D; new MyRedisCacheManager(RedisCacheWriter.nonLockingRedisCacheWriter(redisConnectionFactory()), defaultCacheConfig);</span><br><span class="line">        return redisCacheManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public RedisConnectionFactory redisConnectionFactory() &#123;</span><br><span class="line">        RedisStandaloneConfiguration configuration &#x3D; new RedisStandaloneConfiguration();</span><br><span class="line">        configuration.setHostName(&quot;10.102.132.150&quot;);</span><br><span class="line">        configuration.setPort(6379);</span><br><span class="line">        configuration.setDatabase(0);</span><br><span class="line">        LettuceConnectionFactory factory &#x3D; new LettuceConnectionFactory(configuration);</span><br><span class="line">        return factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public RedisTemplate&lt;String, String&gt; stringRedisTemplate() &#123;</span><br><span class="line">        RedisTemplate&lt;String, String&gt; redisTemplate &#x3D; new StringRedisTemplate();</span><br><span class="line">        redisTemplate.setConnectionFactory(redisConnectionFactory());</span><br><span class="line">        return redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class CacheDemoServiceImpl implements CacheDemoService &#123;</span><br><span class="line"></span><br><span class="line">    @Cacheable(cacheNames &#x3D; &#123;</span><br><span class="line">            &quot;demoCache#3600&quot;, &quot;demoCar#600&quot;, &quot;demoFsx&quot;</span><br><span class="line">    &#125;, key &#x3D; &quot;#id&quot;)</span><br><span class="line">    @Override</span><br><span class="line">    public Object getFromDB(Integer id) &#123;</span><br><span class="line">        System.out.println(&quot;模拟去db查询~~~&quot; + id);</span><br><span class="line">        return &quot;hello cache...&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>备注：以上均参照自以下文章:<br><a href="https://cloud.tencent.com/developer/article/1497599" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1497599</a></p>
<h2 id="让保存的-Redis-数据可视化"><a href="#让保存的-Redis-数据可视化" class="headerlink" title="让保存的 Redis 数据可视化"></a>让保存的 Redis 数据可视化</h2><p>我们上面的例子中 Redis 中序列化后都是可读的 JSON 格式，有的同学数据存到 Redis 中可能是这样的：<br><img src="https://sptan-pic.oss-cn-shanghai.aliyuncs.com/rediscache/QQ20200506-135453.png" alt=""></p>
<p>原因在于没有指定合适的 Redis 序列化类。<br>spring-data-redis 提供如下几种选择（我的环境中包含了两种阿里的实现）:<br><img src="https://sptan-pic.oss-cn-shanghai.aliyuncs.com/rediscache/QQ20200506-135231.png" alt=""><br>默认情况下，使用 JdkSerializationRedisSerializer 这中序列化类，这个序列化器的特点是使用 java 的序列化方式，二进制存储数据，存储的数据格式直接无法人眼识别，但是速度比较快，尤其是占用空间比较小，还是比较适合生产环境的一种序列化方式。</p>
<p>但是往往大多数情况下，Redis 对我们已经足够快，Redis 空间也足够用，我们还想要 redis 数据人眼可视化，这时就需要定制 redis 的序列化器。<br>使用阿里的 FastJsonRedisSerializer 进行 redis 序列化的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ConditionalOnClass(RedisOperations.class)</span><br><span class="line">@EnableConfigurationProperties(RedisProperties.class)</span><br><span class="line">@EnableCaching</span><br><span class="line">public class RedisConfig extends CachingConfigurerSupport &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RedisProperties redisProperties;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    @Bean</span><br><span class="line">    public CacheManager cacheManager() &#123;</span><br><span class="line">        FastJsonRedisSerializer&lt;Object&gt; fastJsonRedisSerializer &#x3D; new FastJsonRedisSerializer&lt;&gt;(Object.class);</span><br><span class="line"></span><br><span class="line">        GenericJackson2JsonRedisSerializer genericJackson2JsonRedisSerializer &#x3D;</span><br><span class="line">                new GenericJackson2JsonRedisSerializer();</span><br><span class="line">        RedisCacheConfiguration defaultCacheConfig &#x3D; RedisCacheConfiguration.defaultCacheConfig()</span><br><span class="line">                .serializeValuesWith(</span><br><span class="line">                RedisSerializationContext.SerializationPair.fromSerializer(fastJsonRedisSerializer))</span><br><span class="line">                .entryTtl(Duration.ofMinutes(60));</span><br><span class="line"></span><br><span class="line">        CustomRedisCacheManager redisCacheManager &#x3D;</span><br><span class="line">                new CustomRedisCacheManager(RedisCacheWriter.nonLockingRedisCacheWriter(redisConnectionFactory()),</span><br><span class="line">                        defaultCacheConfig);</span><br><span class="line">        return redisCacheManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>序列化后长这个样子:<br><img src="https://sptan-pic.oss-cn-shanghai.aliyuncs.com/rediscache/QQ20200506-141912.png" alt=""></p>
<p>把序列化方法改为 GenericJackson2JsonRedisSerializer:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public CacheManager cacheManager() &#123;</span><br><span class="line">    GenericJackson2JsonRedisSerializer genericJackson2JsonRedisSerializer &#x3D;</span><br><span class="line">            new GenericJackson2JsonRedisSerializer();</span><br><span class="line">    RedisCacheConfiguration defaultCacheConfig &#x3D; RedisCacheConfiguration.defaultCacheConfig()</span><br><span class="line">            .serializeValuesWith(</span><br><span class="line">            RedisSerializationContext.SerializationPair.fromSerializer(genericJackson2JsonRedisSerializer))</span><br><span class="line">            .entryTtl(Duration.ofMinutes(60));</span><br><span class="line"></span><br><span class="line">    CustomRedisCacheManager redisCacheManager &#x3D;</span><br><span class="line">            new CustomRedisCacheManager(RedisCacheWriter.nonLockingRedisCacheWriter(redisConnectionFactory()),</span><br><span class="line">                    defaultCacheConfig);</span><br><span class="line">    return redisCacheManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果如下:<br><img src="https://sptan-pic.oss-cn-shanghai.aliyuncs.com/rediscache/QQ20200506-142244.png" alt=""></p>
<p>如果不指定序列化器:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public CacheManager cacheManager() &#123;</span><br><span class="line">     RedisCacheConfiguration defaultCacheConfig &#x3D; RedisCacheConfiguration.defaultCacheConfig()</span><br><span class="line">            &#x2F;&#x2F;.serializeValuesWith(</span><br><span class="line">            &#x2F;&#x2F;RedisSerializationContext.SerializationPair.fromSerializer(genericJackson2JsonRedisSerializer))</span><br><span class="line">            .entryTtl(Duration.ofMinutes(60));</span><br><span class="line"></span><br><span class="line">    CustomRedisCacheManager redisCacheManager &#x3D;</span><br><span class="line">            new CustomRedisCacheManager(RedisCacheWriter.nonLockingRedisCacheWriter(redisConnectionFactory()),</span><br><span class="line">                    defaultCacheConfig);</span><br><span class="line">    return redisCacheManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果如下:<br><img src="https://sptan-pic.oss-cn-shanghai.aliyuncs.com/rediscache/QQ20200506-142606.png" alt=""></p>
<p>个中差别，自己体会。</p>
<h2 id="设置自定义的-key-值"><a href="#设置自定义的-key-值" class="headerlink" title="设置自定义的 key 值"></a>设置自定义的 key 值</h2><p>我们的 redis 配置文件扩展自 CachingConfigurerSupport 类。这个类是接口 CachingConfigurer 的一个极简的实现。代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class CachingConfigurerSupport implements CachingConfigurer &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	@Nullable</span><br><span class="line">	public CacheManager cacheManager() &#123;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	@Nullable</span><br><span class="line">	public CacheResolver cacheResolver() &#123;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	@Nullable</span><br><span class="line">	public KeyGenerator keyGenerator() &#123;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	@Nullable</span><br><span class="line">	public CacheErrorHandler errorHandler() &#123;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改 keyGenerator 的实现方式就可以实现统一的 redis key 生成算法。</p>
<h3 id="不做任何设定-观察缓存-key-值"><a href="#不做任何设定-观察缓存-key-值" class="headerlink" title="不做任何设定,观察缓存 key 值"></a>不做任何设定,观察缓存 key 值</h3><p>不配置自定义的 keyGenerator， 把 Service 类中的@CacheConfig 去掉，@CachePut 所有属性去掉。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">&#x2F;&#x2F;@CacheConfig(cacheNames &#x3D; &quot;banner&quot;)</span><br><span class="line">@Transactional(rollbackFor &#x3D; Exception.class)</span><br><span class="line">public class BannerServiceImpl implements BannerService &#123;</span><br><span class="line">    &#x2F;&#x2F;省略无关属性与方法</span><br><span class="line">    @Override</span><br><span class="line">    &#x2F;&#x2F;@CachePut(value &#x3D; &quot;banner&quot;, key &#x3D; &quot;#result.getId()&quot;)</span><br><span class="line">    @CachePut()</span><br><span class="line">    @Transactional(rollbackFor &#x3D; Exception.class)</span><br><span class="line">    public BannerDTO create(Banner resources) &#123;</span><br><span class="line">        resources.setId(IdUtil.simpleUUID());</span><br><span class="line">        return bannerMapper.toDto(bannerRepository.save(resources));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>项目能正常启动，但是执行新增 banner 操作后出现以下错误:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;timestamp&quot;: &quot;2020-05-06 14:54:12&quot;,</span><br><span class="line">  &quot;status&quot;: 500,</span><br><span class="line">  &quot;error&quot;: &quot;Internal Server Error&quot;,</span><br><span class="line">  &quot;message&quot;: &quot;No cache could be resolved for &#39;Builder[public com.sptan.exec.rediscache.service.dto.BannerDTO com.sptan.exec.rediscache.service.impl.BannerServiceImpl.create(com.sptan.exec.rediscache.domain.Banner)] caches&#x3D;[] | key&#x3D;&#39;&#39; | keyGenerator&#x3D;&#39;&#39; | cacheManager&#x3D;&#39;&#39; | cacheResolver&#x3D;&#39;&#39; | condition&#x3D;&#39;&#39; | unless&#x3D;&#39;&#39;&#39; using resolver &#39;org.springframework.cache.interceptor.SimpleCacheResolver@9478f79&#39;. At least one cache should be provided per cache operation.&quot;,</span><br><span class="line">  &quot;path&quot;: &quot;&#x2F;exec&#x2F;api&#x2F;banner&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据错误信息可以看出缺少 cache 键值属性，我们下面一步步加上。<br>首先为@CachePut 加上 value 属性:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@CachePut(value &#x3D; &quot;banner&quot;)</span><br></pre></td></tr></table></figure>

<p>再次执行，redis 效果如下：<br><img src="https://sptan-pic.oss-cn-shanghai.aliyuncs.com/rediscache/QQ20200506-150425.png" alt=""></p>
<p>redis 完整 key 值如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">banner::Banner(id&#x3D;5268c4a937f14267a83ff3aa81295cd0, bannerName&#x3D;string, imageUrl&#x3D;string, showLocation&#x3D;1, startDate&#x3D;Tue May 05 10:48:59 CST 2020, endDate&#x3D;Tue May 05 10:48:59 CST 2020, bannerType&#x3D;0, goodsId&#x3D;string, goodsName&#x3D;string, content&#x3D;string, createTime&#x3D;null, createUserId&#x3D;null, createUserName&#x3D;null, updateTime&#x3D;null, updateUserId&#x3D;null, updateUserName&#x3D;null)</span><br></pre></td></tr></table></figure>

<p>可以看到完整 key 值由@CachePut 的 value 属性(banner)和生成对象的 toString 方法结果组成。<br>说明一下:我们使用 lombok 框架，BannerDTO 的 toString 方法是 lombok 生成的。</p>
<h3 id="通过-CacheConfig-为-Service-类增加-cacheNames"><a href="#通过-CacheConfig-为-Service-类增加-cacheNames" class="headerlink" title="通过@CacheConfig 为 Service 类增加 cacheNames"></a>通过@CacheConfig 为 Service 类增加 cacheNames</h3><p>为类增加缓存属性设置:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">@CacheConfig(cacheNames &#x3D; &quot;bannerClass&quot;)</span><br><span class="line">@Transactional(rollbackFor &#x3D; Exception.class)</span><br><span class="line">public class BannerServiceImpl implements BannerService &#123;</span><br><span class="line">    &#x2F;&#x2F;省略代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@CachePut 什么属性都不设置:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">@CachePut()</span><br><span class="line">@Transactional(rollbackFor &#x3D; Exception.class)</span><br><span class="line">public BannerDTO create(Banner resources) &#123;</span><br><span class="line">    resources.setId(IdUtil.simpleUUID());</span><br><span class="line">    return bannerMapper.toDto(bannerRepository.save(resources));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果如下:<br><img src="https://sptan-pic.oss-cn-shanghai.aliyuncs.com/rediscache/QQ20200506-151641.png" alt=""></p>
<h3 id="通过-Cacheable-或者-CachePut-等其他注解-为方法追加方法级的属性"><a href="#通过-Cacheable-或者-CachePut-等其他注解-为方法追加方法级的属性" class="headerlink" title="通过@Cacheable(或者@CachePut 等其他注解) 为方法追加方法级的属性"></a>通过@Cacheable(或者@CachePut 等其他注解) 为方法追加方法级的属性</h3><p>为@CachePut 增加 value 属性:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">@CachePut(value &#x3D; &quot;bannerMethod&quot;)</span><br><span class="line">@Transactional(rollbackFor &#x3D; Exception.class)</span><br><span class="line">public BannerDTO create(Banner resources) &#123;</span><br><span class="line">    resources.setId(IdUtil.simpleUUID());</span><br><span class="line">    return bannerMapper.toDto(bannerRepository.save(resources));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果如下:<br><img src="https://sptan-pic.oss-cn-shanghai.aliyuncs.com/rediscache/QQ20200506-152115.png" alt=""></p>
<p>可以看到@CachePut 的 value 会覆盖@CacheConfig 的 cacheNames 属性设置。</p>
<p>redis 缓存的 key 前缀设置好了，但是 key 值仍旧不好，一般来说，对于单个对象，把对象的主键作为 key 值是比较自然的方式,我们这么改一下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">@CachePut(value &#x3D; &quot;bannerPrimaryKey&quot;, key &#x3D; &quot;#result.getId()&quot;)</span><br><span class="line">@Transactional(rollbackFor &#x3D; Exception.class)</span><br><span class="line">public BannerDTO create(Banner resources) &#123;</span><br><span class="line">    resources.setId(IdUtil.simpleUUID());</span><br><span class="line">    return bannerMapper.toDto(bannerRepository.save(resources));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果如下:<br><img src="https://sptan-pic.oss-cn-shanghai.aliyuncs.com/rediscache/QQ20200506-152633.png" alt=""><br>这样爽多了。不知道能否治愈你的强迫症？</p>
<h3 id="KeyGenerator-定制化-key-值"><a href="#KeyGenerator-定制化-key-值" class="headerlink" title="KeyGenerator 定制化 key 值"></a>KeyGenerator 定制化 key 值</h3><p>经过几次改动，上面的方式已经比较好了，不过上面已经提到了我们可以定制 keyGenerator，定制后我们可以拿到一个比较短的 key 值。<br>我们重写一下 keyGenerator 方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@Configuration</span><br><span class="line">@ConditionalOnClass(RedisOperations.class)</span><br><span class="line">@EnableConfigurationProperties(RedisProperties.class)</span><br><span class="line">@EnableCaching</span><br><span class="line">public class RedisConfig extends CachingConfigurerSupport &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 自定义缓存key生成策略，默认将使用该策略</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Bean</span><br><span class="line">    @Override</span><br><span class="line">    public KeyGenerator keyGenerator() &#123;</span><br><span class="line">        return (target, method, params) -&gt; &#123;</span><br><span class="line">            Map&lt;String, Object&gt; container &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">            Class&lt;?&gt; targetClassClass &#x3D; target.getClass();</span><br><span class="line">            &#x2F;&#x2F; 类地址</span><br><span class="line">            container.put(&quot;class&quot;, targetClassClass.toGenericString());</span><br><span class="line">            &#x2F;&#x2F; 方法名称</span><br><span class="line">            container.put(&quot;methodName&quot;, method.getName());</span><br><span class="line">            &#x2F;&#x2F; 包名称</span><br><span class="line">            container.put(&quot;package&quot;, targetClassClass.getPackage());</span><br><span class="line">            &#x2F;&#x2F; 参数列表</span><br><span class="line">            for (int i &#x3D; 0; i &lt; params.length; i++) &#123;</span><br><span class="line">                container.put(String.valueOf(i), params[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 转为JSON字符串</span><br><span class="line">            String jsonString &#x3D; JSON.toJSONString(container);</span><br><span class="line">            &#x2F;&#x2F; 做SHA256 Hash计算，得到一个SHA256摘要作为Key</span><br><span class="line">            return DigestUtils.sha256Hex(jsonString);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们这里根据方法的包名、类名、方法名以及参数做摘要签名。<br>以下面这个分页查询方法看看效果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">@Cacheable</span><br><span class="line">public Map&lt;String, Object&gt; queryByPage(BannerQueryCriteria criteria, Pageable pageable) &#123;</span><br><span class="line">    Page&lt;Banner&gt; page &#x3D;</span><br><span class="line">            bannerRepository.findAll((root, criteriaQuery, criteriaBuilder) -&gt; QueryHelp.getPredicate(root, criteria,</span><br><span class="line">                    criteriaBuilder), pageable);</span><br><span class="line">    return PageUtil.toPage(page.map(bannerMapper::toDto));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果如下：<br><img src="https://sptan-pic.oss-cn-shanghai.aliyuncs.com/rediscache/QQ20200506-153710.png" alt=""><br>可见我们键值策略起作用了。</p>
<p>我们不使用全局的键值策略，为分页查询重新定义键值:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">@Cacheable(value &#x3D; &quot;hashCodeKey&quot;, key &#x3D; &quot;&#39;key:p0:&#39; + #p0.hashCode() + &#39;p1:&#39; + #p1.hashCode()&quot;)</span><br><span class="line">public Map&lt;String, Object&gt; queryByPage(BannerQueryCriteria criteria, Pageable pageable) &#123;</span><br><span class="line">    Page&lt;Banner&gt; page &#x3D;</span><br><span class="line">            bannerRepository.findAll((root, criteriaQuery, criteriaBuilder) -&gt; QueryHelp.getPredicate(root, criteria,</span><br><span class="line">                    criteriaBuilder), pageable);</span><br><span class="line">    return PageUtil.toPage(page.map(bannerMapper::toDto));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果如下:<br><img src="https://sptan-pic.oss-cn-shanghai.aliyuncs.com/rediscache/QQ20200506-153918.png" alt=""></p>
<p>实现自定义的键值策略时一定要注意键值的唯一性，如果不同的缓存结果生成了同样的缓存键值，就会造成数据错误。</p>
<h1 id="SpringBoot-2-x-中常见的-Redis-缓存问题"><a href="#SpringBoot-2-x-中常见的-Redis-缓存问题" class="headerlink" title="SpringBoot 2.x 中常见的 Redis 缓存问题"></a>SpringBoot 2.x 中常见的 Redis 缓存问题</h1><p>SpringBoot 1.5.x 版本 Redis 客户端默认是 Jedis 实现的，SpringBoot 2.x 版本中默认客户端是用 Lettuce 实现的，两种实现差异比较大，从 SpringBoot1.x 升级到 SpringBoot2.x 后会发现之前好用的配置变得总出问题，对于常见问题我们说明一下解决方法。</p>
<h2 id="Lettuce-简介与使用举例"><a href="#Lettuce-简介与使用举例" class="headerlink" title="Lettuce 简介与使用举例"></a>Lettuce 简介与使用举例</h2><p>Jedis 在实现上是直连 Redis 服务，多线程环境下非线程安全，除非使用连接池，为每个 RedisConnection 实例增加物理连接。<br>Lettuce 是一种可伸缩，线程安全，完全非阻塞的 Redis 客户端，多个线程可以共享一个 RedisConnection，它利用 Netty NIO 框架来高效地管理多个连接，从而提供了异步和同步数据访问方式，用于构建非阻塞的反应性应用程序。</p>
<p>要注意由于 SpringBoot 2.x 中默认并没有使用 Redis 连接池，所以需要在 pom.xml 中添加 commons-pool2 的依赖:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--spring2.0集成redis所需common-pool2--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.commons&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-pool2&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;commons-pool2.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>连接池配置如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public RedisConnectionFactory redisConnectionFactory() &#123;</span><br><span class="line">    &#x2F;&#x2F;commons-pool2包</span><br><span class="line">    GenericObjectPoolConfig poolConfig &#x3D; new GenericObjectPoolConfig();</span><br><span class="line">    poolConfig.setMaxIdle(100);</span><br><span class="line">    poolConfig.setMinIdle(10);</span><br><span class="line">    poolConfig.setMaxTotal(500);</span><br><span class="line">    poolConfig.setMaxWaitMillis(1000);</span><br><span class="line">    poolConfig.setTestOnBorrow(true);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 基本连接信息：host port database password</span><br><span class="line">    RedisStandaloneConfiguration redisStandaloneConfiguration &#x3D; new RedisStandaloneConfiguration();</span><br><span class="line">    redisStandaloneConfiguration.setHostName(redisProperties.getHost());</span><br><span class="line">    redisStandaloneConfiguration.setPort(redisProperties.getPort());</span><br><span class="line">    redisStandaloneConfiguration.setDatabase(redisProperties.getDatabase());</span><br><span class="line">    if (null !&#x3D; redisProperties.getPassword()) &#123;</span><br><span class="line">        redisStandaloneConfiguration.setPassword(RedisPassword.of(redisProperties.getPassword()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;这里单独配置超时时间，连接池管理</span><br><span class="line">    LettuceClientConfiguration lettuceClientConfiguration &#x3D; LettucePoolingClientConfiguration.builder()</span><br><span class="line">        .commandTimeout(Duration.ofMillis(20000)).shutdownTimeout(Duration.ofMillis(20000)).poolConfig</span><br><span class="line">            (poolConfig)</span><br><span class="line">        .build();</span><br><span class="line">    LettuceConnectionFactory lettuceConnectionFactory &#x3D; new LettuceConnectionFactory</span><br><span class="line">        (redisStandaloneConfiguration, lettuceClientConfiguration);</span><br><span class="line">    lettuceConnectionFactory.setValidateConnection(true);</span><br><span class="line">    lettuceConnectionFactory.setShareNativeConnection(false);</span><br><span class="line">    return lettuceConnectionFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Lettuce 的使用过程中有些坑,写到这里本文已经太长了，另开文章讨论。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/%E7%BC%93%E5%AD%98/" rel="tag"># 缓存</a>
          
            <a href="/tags/Redis/" rel="tag"># Redis</a>
          
            <a href="/tags/Cache/" rel="tag"># Cache</a>
          
            <a href="/tags/SpringBoot/" rel="tag"># SpringBoot</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/05/01/Java%E4%B8%AD%E4%B8%80%E6%9D%A1%E8%AF%AD%E5%8F%A5%E6%90%9E%E5%AE%9A%E9%9B%86%E5%90%88%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96/" rel="next" title="Java中一条语句搞定集合类初始化">
                <i class="fa fa-chevron-left"></i> Java中一条语句搞定集合类初始化
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/05/01/Redis5%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E/" rel="prev" title="Redis5配置说明">
                Redis5配置说明 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="http://sptan-public.oss-cn-beijing.aliyuncs.com/sptanlp.png"
                alt="Sptan" />
            
              <p class="site-author-name" itemprop="name">Sptan</p>
              <p class="site-description motion-element" itemprop="description">人懒,记性还不好,只能写下来</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/liupengblog" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.ruanyifeng.com/blog/" title="阮一峰的网络日志" target="_blank">阮一峰的网络日志</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#简介"><span class="nav-number">1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SpringBoot-中启用-Redis-缓存"><span class="nav-number">2.</span> <span class="nav-text">SpringBoot 中启用 Redis 缓存</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#使用注解式缓存"><span class="nav-number">3.</span> <span class="nav-text">使用注解式缓存</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#主要注解的解释"><span class="nav-number">4.</span> <span class="nav-text">主要注解的解释</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#CacheConfig"><span class="nav-number">4.1.</span> <span class="nav-text">@CacheConfig</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Cacheable"><span class="nav-number">4.2.</span> <span class="nav-text">@Cacheable</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CachePut"><span class="nav-number">4.3.</span> <span class="nav-text">@CachePut</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CacheEvict"><span class="nav-number">4.4.</span> <span class="nav-text">@CacheEvict</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Cacheable-使用举例"><span class="nav-number">4.5.</span> <span class="nav-text">@Cacheable 使用举例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#查询单个对象"><span class="nav-number">4.5.1.</span> <span class="nav-text">查询单个对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分页查询"><span class="nav-number">4.5.2.</span> <span class="nav-text">分页查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为-Service-设置-CacheNames"><span class="nav-number">4.5.3.</span> <span class="nav-text">为 Service 设置 CacheNames</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CacheEvict-使用举例"><span class="nav-number">4.6.</span> <span class="nav-text">@CacheEvict 使用举例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CachePut-使用举例"><span class="nav-number">4.7.</span> <span class="nav-text">@CachePut 使用举例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Caching-使用举例"><span class="nav-number">4.8.</span> <span class="nav-text">@Caching 使用举例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CacheConfig-使用举例"><span class="nav-number">4.9.</span> <span class="nav-text">@CacheConfig 使用举例</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#条件式缓存"><span class="nav-number">5.</span> <span class="nav-text">条件式缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#条件参数"><span class="nav-number">5.1.</span> <span class="nav-text">条件参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#排除性条件参数"><span class="nav-number">5.2.</span> <span class="nav-text">排除性条件参数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#常用缓存配置"><span class="nav-number">6.</span> <span class="nav-text">常用缓存配置</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#失效时间设定"><span class="nav-number">6.1.</span> <span class="nav-text">失效时间设定</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#更精确一点的配置"><span class="nav-number">6.2.</span> <span class="nav-text">更精确一点的配置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#准备-Cache-配置："><span class="nav-number">6.2.1.</span> <span class="nav-text">准备 Cache 配置：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#单个方法级别的缓存失效时间配置"><span class="nav-number">6.3.</span> <span class="nav-text">单个方法级别的缓存失效时间配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#让保存的-Redis-数据可视化"><span class="nav-number">6.4.</span> <span class="nav-text">让保存的 Redis 数据可视化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#设置自定义的-key-值"><span class="nav-number">6.5.</span> <span class="nav-text">设置自定义的 key 值</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#不做任何设定-观察缓存-key-值"><span class="nav-number">6.5.1.</span> <span class="nav-text">不做任何设定,观察缓存 key 值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通过-CacheConfig-为-Service-类增加-cacheNames"><span class="nav-number">6.5.2.</span> <span class="nav-text">通过@CacheConfig 为 Service 类增加 cacheNames</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通过-Cacheable-或者-CachePut-等其他注解-为方法追加方法级的属性"><span class="nav-number">6.5.3.</span> <span class="nav-text">通过@Cacheable(或者@CachePut 等其他注解) 为方法追加方法级的属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#KeyGenerator-定制化-key-值"><span class="nav-number">6.5.4.</span> <span class="nav-text">KeyGenerator 定制化 key 值</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SpringBoot-2-x-中常见的-Redis-缓存问题"><span class="nav-number">7.</span> <span class="nav-text">SpringBoot 2.x 中常见的 Redis 缓存问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Lettuce-简介与使用举例"><span class="nav-number">7.1.</span> <span class="nav-text">Lettuce 简介与使用举例</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sptan</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
